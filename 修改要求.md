根据“实用性优先”原则以及老师强调的“增加数据库设计复杂度和难度”的要求，最高优先级的修改方案是：将“选课逻辑”从应用层（Go代码）下沉到数据库层（存储过程），并引入“课程先修”和“容量控制”机制。

这一改动能直接击中老师评分标准中的三个核心点：

复杂性：引入了课程之间的依赖关系（自关联，Graph结构）。

难度：使用了存储过程（Stored Procedure）和事务（Transaction）保证数据一致性，防止“超卖”。

条理性：体现了“先设计数据库逻辑，再写代码”的正确套路。

以下是具体的实施步骤，请直接在你的项目中执行：

第一步：数据库 Schema 升级 (SQL)
你需要先扩展现有的表结构，支持课程容量限制和先修课关系。请在 MySQL 中执行以下 SQL（或者追加到你的 init.sql 中）：

SQL

-- 1. 修改 courses 表，增加容量控制字段
ALTER TABLE courses 
ADD COLUMN capacity INT DEFAULT 50 COMMENT '课程最大容量',
ADD COLUMN enrolled_count INT DEFAULT 0 COMMENT '当前已选人数';

-- 2. 新增 course_prerequisites 表 (课程先修关系 - 多对多自关联)
-- 这是一个典型的“复杂”关系设计，体现ER图的深度
CREATE TABLE IF NOT EXISTS course_prerequisites (
    course_id INT NOT NULL COMMENT '当前课程ID',
    prereq_id INT NOT NULL COMMENT '先修课程ID',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (course_id, prereq_id),
    FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE,
    FOREIGN KEY (prereq_id) REFERENCES courses(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 为性能优化添加索引 (体现“难度/难点”中的索引分析)
CREATE INDEX idx_prereq_course ON course_prerequisites(prereq_id);
第二步：核心“大杀器” —— 智能选课存储过程 (SQL)
这是最能加分的部分。不要用 Gorm 的简单 Create，而是用下面的存储过程来接管选课逻辑。它利用了事务来保证高并发下的数据安全。

SQL

DELIMITER //

CREATE PROCEDURE sp_enroll_student(
    IN p_student_id INT,
    IN p_course_id INT,
    OUT p_status INT,       -- 0: 成功, 1: 失败
    OUT p_message VARCHAR(255)
)
BEGIN
    DECLARE v_capacity INT;
    DECLARE v_enrolled INT;
    DECLARE v_already_enrolled INT;
    DECLARE v_prereq_count INT;
    DECLARE v_prereq_met INT;

    -- 开启事务，保证原子性
    START TRANSACTION;

    -- 1. 检查是否重复选课
    SELECT COUNT(*) INTO v_already_enrolled 
    FROM enrollments 
    WHERE student_id = p_student_id AND course_id = p_course_id AND deleted_at IS NULL;

    IF v_already_enrolled > 0 THEN
        SET p_status = 1;
        SET p_message = '这门课你已经选过了';
        ROLLBACK;
    ELSE
        -- 2. 检查先修课程要求 (核心逻辑：体现复杂性)
        -- 统计该课程有多少门先修课
        SELECT COUNT(*) INTO v_prereq_count 
        FROM course_prerequisites 
        WHERE course_id = p_course_id;

        -- 统计学生已经修完并通过(假设成绩>=60)的先修课数量
        SELECT COUNT(*) INTO v_prereq_met
        FROM course_prerequisites cp
        JOIN enrollments e ON cp.prereq_id = e.course_id
        JOIN grades g ON e.id = g.enrollment_id
        WHERE cp.course_id = p_course_id 
          AND e.student_id = p_student_id
          AND g.score >= 60; -- 假设60分及格

        IF v_prereq_met < v_prereq_count THEN
            SET p_status = 1;
            SET p_message = '先修课程未完成，无法选课';
            ROLLBACK;
        ELSE
            -- 3. 检查并锁定课程容量 (使用 FOR UPDATE 加行锁，防止并发超卖)
            SELECT capacity, enrolled_count INTO v_capacity, v_enrolled
            FROM courses
            WHERE id = p_course_id
            FOR UPDATE;

            IF v_enrolled >= v_capacity THEN
                SET p_status = 1;
                SET p_message = '课程已满员';
                ROLLBACK;
            ELSE
                -- 4. 执行选课：插入记录并更新计数
                INSERT INTO enrollments (created_at, updated_at, student_id, course_id)
                VALUES (NOW(), NOW(), p_student_id, p_course_id);

                UPDATE courses 
                SET enrolled_count = enrolled_count + 1 
                WHERE id = p_course_id;

                SET p_status = 0;
                SET p_message = '选课成功';
                COMMIT;
            END IF;
        END IF;
    END IF;
END //

DELIMITER ;
第三步：Go 后端代码适配
在 backend/internal/api/v1/enrollment.go (或其他处理选课的 Controller) 中，放弃使用 db.Create(&enrollment)，改为调用上述存储过程。

修改建议 (Go):

Go

// EnrollmentController 中的 Create 方法修改示例
// POST /api/v1/enrollments
func (h *EnrollmentHandler) Create(c *gin.Context) {
    var req struct {
        StudentID uint `json:"student_id" binding:"required"`
        CourseID  uint `json:"course_id" binding:"required"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "无效的请求参数"})
        return
    }

    var status int
    var message string

    // 使用 Gorm 的 Raw 或 Exec 调用存储过程
    // 注意：这里利用了 MySQL 驱动对 OUT 参数的支持，或者直接获取 Result Set
    // 简便写法：直接用 Select 获取结果，把 OUT 参数改成 SELECT 输出会更通用
    // 但为了严谨使用存储过程调用：
    
    db := global.DB // 假设你有全局DB对象
    
    // 执行存储过程
    // 这里的 SQL 语法取决于驱动，通常可以使用如下方式：
    err := db.Raw("CALL sp_enroll_student(?, ?, @status, @message)", req.StudentID, req.CourseID).Scan(&struct{}{}).Error;
    // 接着获取 OUT 参数
    type Result struct {
        Status  int
        Message string
    }
    var res Result
    db.Raw("SELECT @status as status, @message as message").Scan(&res)

    if res.Status != 0 {
        c.JSON(400, gin.H{"code": 400, "message": res.Message})
        return
    }

    c.JSON(200, gin.H{"code": 200, "message": "选课成功"})
}